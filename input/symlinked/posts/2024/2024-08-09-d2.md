---
title: "Diagramming with D2: How and Why"
meta_description: ""
featured_img: /_images/default-thumb.png
excerpt: "TODO: Write an excerpt"
tags: ["Documentation", "Async Communication", "Software Engineering", "Design"]
hn_link:
---

I have a bit of a love/hate relationship with diagrams. 

I love them because they have the ability to communicate in a way that words just do not. This can create shared context much faster than just a description on its own. Creating a diagram can be a great exercise in understanding a new system: draw it up as you understand it and share it with someone who can validate it (or not). They also just look the part and can break up a long wall of text, giving the reader a break from the educational onslaught.

I hate them because all of the above are qualified: a diagram simply being present does not guarantee better outcomes. You can sink 2x, 3x, 5x the amount of time needed fiddling with arrows and boxes, trying to get perfect alignment in whatever tool you're using. Once they're created, keeping them up-to-date on a team is challenging for reasons ranging from different aesthetic senses to multiple file formats (looking at you, diagrams.net) to them being just one more thing to do. The risk is that you spend lots of time and end up with something that's hard to keep up-to-date and doesn't actually help people understand the thing. 

Case in point, here is about 5% of a systems diagram I found at work describing the interconnectivity between the services that power our product:

```
complex-system-diagram.png
```

I also found this diagram online detailing a [release pipeline for Mozilla](https://www.chesnok.com/daily/2014/05/02/release-engineering-a-draft-of-an-architecture-diagram/):

```
releng-flow-onepage.png
```

I am part of the audience for the former and, if I changed employers, I could be for the latter. In both cases, the diagram does less to increase my understanding of the system than it does to make me think, "whoa, this is complex."

Diagrams, like all the tools we use to create understanding in other people, have their place. With the right combination of these tools, we can create more understanding in more people and that, objectively, is more good than not doing that. But, like all those other tools, diagrams need to be deployed thoughtfully and intensionally for them to have a positive impact. Just like screenshots, sample code, metaphors, and videos, the existence of a diagram does not, de facto, improve understanding. 

I moved from software engineering to architecture in the beginning of 2023. One of the main components of what I did on that team was taking time to understand a system as completely as I can, figuring out how to improve or add to that system, and then explaining the current and proposed after states to various interested parties. This requires direct, concise, and timely technical communication, of which diagrams have been an excellent tool. 

But all the cons that I talked about above started standing out when it became clear that diagrams were more than just a line item on a detailed solution document. I was seeing so many different places where we were using words in documentation, then words on Slack, then words in a meeting and still not coming to the level of shared understanding that we needed. There seemed to be a number of places where a diagram would help but the time trade-off loomed large. 

So I started a side quest in the middle of last year to figure out how to do diagrams The Right Way ‚Ñ¢Ô∏è. I started by writing down what I knew was true:

- Documents including clear and accurate diagrams are preferred over ones with all text.
- Documentation rot is a fact of life and these diagrams will, inevitably, go out of date. Software changes easily, quickly, and often. The solution here has to address that fact in some way.
- There is a place where returns diminish, where the effort to create and maintain this kind of documentation exceeds its utility. If it takes 2 weeks to create it and maintain it for a year and it's only used by two people, saving a day or two of work, then was it worth it? It's difficult to do the math accurately if we recover from, or avoid, a major incident.
- The time to create diagrams is when the system is being built (information is fresh) or when someone is learning it end-to-end (discovery can be checked with a SME). Waiting until the end to construct the whole thing is dangerous ("oops, ran out of time") but doing it iteratively can take a lot of time if you're fiddling with arrows and box sizes and label formatting.
- If you're diagramming sensitive internal systems then your choices are to use the company-approved cloud solution (UI-heavy, all-in-one "visual collaboration platform") or keep it local.

With all of this in mind, I went exploring on Hacker News, Reddit, and Google. I was pretty sure early on that the resting format that would be the most helpful for the above was plain text. This would allow storage in GitHub (company-approved), which would in turn enable versioning with diffs. This would also mean that keeping diagrams next to the code that's being described, allowing diagram updates in the same PR as code updates. Storage in XML or JSON or another structured format might be acceptable for those reasons but the idea of creating, editing, storing, and sharing in text was enticing, if I could find it. And, if I'm being honest, plain text is pretty much the best anywhere that humans are involved (link).

I won't bore you with all the details (some of the other systems I considered are linked at the bottom of this post) but I landed on [D2](https://d2lang.com/) as the most promising way forward. Here's what I liked:

- Diagrams are PNG or SVG images generated from plain text üéâ üéâ üéâ
- The output looked quite good at first glance! This might seem like a small thing but if you're communicating visually then it needs to draw people in quickly.
- The diagrams are procedurally generated so you won't be losing hours to fiddling with arrows and boxes.
- The generator is open-source, well maintained, and well documented. 

D2 pretty much checked every box right out of the gate so I was super excited to try it out. I walked through the whole [tour](https://d2lang.com/tour/intro) and, by the end, was totally sold. [Variables](https://d2lang.com/tour/vars) (re-usable styling and text)! [Composition](https://d2lang.com/tour/composition) (multiple diagrams combined)! [Imports](https://d2lang.com/tour/imports) (built out reusable components)! At the end of the tour, my mind was spinning with possibilities and I was ready to get started.

I knew from the start that my main evaluation criteria would be whether or not the generated output was good enough to give up complete control. One thing I learned to do pretty quickly was to create reusable styles for certain node types. I'm able to define a whole set of different entities that can be easily used in different diagrams. 

```
... example ... 
```

I'm keeping my diagrams in their own repo so I'm able to define low-level themes and keep a similar aesthetic between different diagrams. When I'm able to just come in and start defining nodes and relationships quickly, the barrier to entry is much lower and I'm more likely to make simple diagrams more often (more on that later).

With the critical task of making things look pretty out of the way, I turned towards the task of evaluating whether I could make clear and concise diagrams quickly. I started recreating some of the diagrams I had built previously in other tools like LucidChart, Diagrams.net, and PowerPoint.

- Reorder actors and connections
- Change/remove connection 

---

- https://www.educative.io/blog/software-architecture-diagramming-and-patterns
- https://c4model.com/
- http://fmc-modeling.org/
- https://www.yworks.com/products/yed
- https://plantuml.com/
	- https://plantuml.com/component-diagram
	- https://www.planttext.com/
- https://graphviz.org/
	- https://ncona.com/2020/06/create-diagrams-with-code-using-graphviz/
	- https://news.ycombinator.com/item?id=23475225
- https://diagrams.mingrammer.com/
- https://mermaid.js.org/syntax/c4.html
